{"ast":null,"code":"import { HttpErrorResponse } from '@angular/common/http';\nimport { throwError, BehaviorSubject } from 'rxjs';\nimport { catchError, filter, take, switchMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@features/users\";\nexport class TokenInterceptor {\n  constructor(authService) {\n    this.authService = authService;\n    this.isRefreshing = false;\n    this.refreshTokenSubject = new BehaviorSubject(null);\n  }\n  intercept(request, next) {\n    const accessToken = this.authService.getAccessToken();\n    if (accessToken) {\n      request = this.addToken(request, accessToken);\n    }\n    return next.handle(request).pipe(catchError(error => {\n      if (error instanceof HttpErrorResponse && error.status === 401) {\n        return this.handle401Error(request, next);\n      } else {\n        return throwError(() => error);\n      }\n    }));\n  }\n  addToken(request, accessToken) {\n    return request.clone({\n      setHeaders: {\n        'Authorization': `Bearer ${accessToken}`\n      }\n    });\n  }\n  handle401Error(request, next) {\n    if (!this.isRefreshing) {\n      this.isRefreshing = true;\n      this.refreshTokenSubject.next(null);\n      return this.authService.refreshToken().pipe(switchMap(tokens => {\n        this.isRefreshing = false;\n        this.refreshTokenSubject.next(tokens.accessToken);\n        return next.handle(this.addToken(request, tokens.accessToken));\n      }));\n    } else {\n      return this.refreshTokenSubject.pipe(filter(token => token != null), take(1), switchMap(accessToken => {\n        return next.handle(this.addToken(request, accessToken));\n      }));\n    }\n  }\n}\nTokenInterceptor.ɵfac = function TokenInterceptor_Factory(t) {\n  return new (t || TokenInterceptor)(i0.ɵɵinject(i1.AuthService));\n};\nTokenInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TokenInterceptor,\n  factory: TokenInterceptor.ɵfac\n});","map":{"version":3,"mappings":"AACA,SAA+DA,iBAAiB,QAAQ,sBAAsB;AAE9G,SAAqBC,UAAU,EAAEC,eAAe,QAAQ,MAAM;AAC9D,SAASC,UAAU,EAAEC,MAAM,EAAEC,IAAI,EAAEC,SAAS,QAAQ,gBAAgB;;;AAKpE,OAAM,MAAOC,gBAAgB;EAI3BC,YAA6BC,WAAwB;IAAxB,gBAAW,GAAXA,WAAW;IAHhC,iBAAY,GAAG,KAAK;IACpB,wBAAmB,GAAyB,IAAIP,eAAe,CAAM,IAAI,CAAC;EAEzB;EAEzDQ,SAAS,CAACC,OAAyB,EAAEC,IAAiB;IACpD,MAAMC,WAAW,GAAG,IAAI,CAACJ,WAAW,CAACK,cAAc,EAAE;IAErD,IAAID,WAAW,EAAE;MACfF,OAAO,GAAG,IAAI,CAACI,QAAQ,CAACJ,OAAO,EAAEE,WAAW,CAAC;;IAG/C,OAAOD,IAAI,CAACI,MAAM,CAACL,OAAO,CAAC,CAACM,IAAI,CAACd,UAAU,CAACe,KAAK,IAAG;MAClD,IAAIA,KAAK,YAAYlB,iBAAiB,IAAIkB,KAAK,CAACC,MAAM,KAAK,GAAG,EAAE;QAC9D,OAAO,IAAI,CAACC,cAAc,CAACT,OAAO,EAAEC,IAAI,CAAC;OAC1C,MAAM;QACL,OAAOX,UAAU,CAAC,MAAMiB,KAAK,CAAC;;IAElC,CAAC,CAAC,CAAC;EACL;EAEQH,QAAQ,CAACJ,OAAyB,EAAEE,WAAmB;IAC7D,OAAOF,OAAO,CAACU,KAAK,CAAC;MACnBC,UAAU,EAAE;QACV,eAAe,EAAE,UAAUT,WAAW;;KAEzC,CAAC;EACJ;EAEQO,cAAc,CAACT,OAAyB,EAAEC,IAAiB;IACjE,IAAI,CAAC,IAAI,CAACW,YAAY,EAAE;MACtB,IAAI,CAACA,YAAY,GAAG,IAAI;MACxB,IAAI,CAACC,mBAAmB,CAACZ,IAAI,CAAC,IAAI,CAAC;MAEnC,OAAO,IAAI,CAACH,WAAW,CAACgB,YAAY,EAAE,CAACR,IAAI,CACzCX,SAAS,CAAEoB,MAAuB,IAAI;QACpC,IAAI,CAACH,YAAY,GAAG,KAAK;QACzB,IAAI,CAACC,mBAAmB,CAACZ,IAAI,CAACc,MAAM,CAACb,WAAW,CAAC;QAEjD,OAAOD,IAAI,CAACI,MAAM,CAAC,IAAI,CAACD,QAAQ,CAACJ,OAAO,EAAEe,MAAM,CAACb,WAAW,CAAC,CAAC;MAChE,CAAC,CAAC,CAAC;KACN,MAAM;MACL,OAAO,IAAI,CAACW,mBAAmB,CAACP,IAAI,CAClCb,MAAM,CAACuB,KAAK,IAAIA,KAAK,IAAI,IAAI,CAAC,EAC9BtB,IAAI,CAAC,CAAC,CAAC,EACPC,SAAS,CAACO,WAAW,IAAG;QACtB,OAAOD,IAAI,CAACI,MAAM,CAAC,IAAI,CAACD,QAAQ,CAACJ,OAAO,EAAEE,WAAW,CAAC,CAAC;MACzD,CAAC,CAAC,CAAC;;EAET;;AAlDWN,gBAAgB;mBAAhBA,gBAAgB;AAAA;AAAhBA,gBAAgB;SAAhBA,gBAAgB;EAAAqB,SAAhBrB,gBAAgB;AAAA","names":["HttpErrorResponse","throwError","BehaviorSubject","catchError","filter","take","switchMap","TokenInterceptor","constructor","authService","intercept","request","next","accessToken","getAccessToken","addToken","handle","pipe","error","status","handle401Error","clone","setHeaders","isRefreshing","refreshTokenSubject","refreshToken","tokens","token","factory"],"sourceRoot":"","sources":["/home/eagold/MyFiles/FASystem/FASystemClient/src/app/core/services/interceptors/token.interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HttpErrorResponse } from '@angular/common/http';\n\nimport { Observable, throwError, BehaviorSubject } from 'rxjs';\nimport { catchError, filter, take, switchMap } from 'rxjs/operators';\n\nimport { AuthService, TokensInterface } from '@features/users';\n\n@Injectable()\nexport class TokenInterceptor implements HttpInterceptor {\n  private isRefreshing = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(private readonly authService: AuthService) { }\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const accessToken = this.authService.getAccessToken()\n\n    if (accessToken) {\n      request = this.addToken(request, accessToken);\n    }\n\n    return next.handle(request).pipe(catchError(error => {\n      if (error instanceof HttpErrorResponse && error.status === 401) {\n        return this.handle401Error(request, next);\n      } else {\n        return throwError(() => error);\n      }\n    }));\n  }\n\n  private addToken(request: HttpRequest<any>, accessToken: string) {\n    return request.clone({\n      setHeaders: {\n        'Authorization': `Bearer ${accessToken}`\n      }\n    });\n  }\n\n  private handle401Error(request: HttpRequest<any>, next: HttpHandler) {\n    if (!this.isRefreshing) {\n      this.isRefreshing = true;\n      this.refreshTokenSubject.next(null);\n\n      return this.authService.refreshToken().pipe(\n        switchMap((tokens: TokensInterface) => {\n          this.isRefreshing = false;\n          this.refreshTokenSubject.next(tokens.accessToken);\n\n          return next.handle(this.addToken(request, tokens.accessToken));\n        }));\n    } else {\n      return this.refreshTokenSubject.pipe(\n        filter(token => token != null),\n        take(1),\n        switchMap(accessToken => {\n          return next.handle(this.addToken(request, accessToken));\n        }));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}