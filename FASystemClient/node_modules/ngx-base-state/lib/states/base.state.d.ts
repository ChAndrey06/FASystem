import { OnDestroy } from '@angular/core';
import { Observable } from 'rxjs';
import { ɵInitialConfig } from '../interfaces';
import * as i0 from "@angular/core";
/**
 *	@class
 *	@classdes This is a base class that used for creating hight level state classes
 */
export declare abstract class BaseState<T> implements OnDestroy {
    /** Initial data should be passed via the `super` method call. */
    protected readonly initialData: T | null;
    /** Initial config should be passed via the `super` method call. */
    private readonly initialConfig;
    /**
     * 	Get `Observable` with state data.
     *  @public
     *	@return {Generic} Observable with the state data.
     */
    get data$(): Observable<T | null>;
    /**
     * 	Get state data.
     *  @public
     *	@return {Generic} State data.
     */
    get data(): T | null;
    /**
     * 	Main `BehaviorSubject` with state data.
     *  @private
     */
    private readonly _data$;
    private readonly _devtoolsConfig;
    private readonly _metadataStorage;
    private _currentlyInvokedAction;
    private _stackTraceOfCurrentlyInvokedAction;
    constructor(
    /** Initial data should be passed via the `super` method call. */
    initialData?: T | null, 
    /** Initial config should be passed via the `super` method call. */
    initialConfig?: ɵInitialConfig | null);
    /**
     *  Base implementation of `ngOnDestroy`.
     *  Don't forget to call `super.ngOnDestroy` in case of override.
     *  @public
     */
    ngOnDestroy(): void;
    /**
     *  Set new value to state
     *  @public
     *	@param {Generic} value - the value that should be set to update `BehaviorSubject`.
     */
    set(value: T): void;
    /**
     *  Clear state value. (Will be set `null`)
     *  @public
     */
    clear(): void;
    /**
     *  Restore initial data from constructor.
     *  @public
     */
    restoreInitialData(): void;
    /**
     *  Method for set data functionality. It may be expanded.
     *  The idea is to process the creation of new instances of complex structures.
     *  @protected
     *	@param {Generic | null} value - the value that should be set to update `BehaviorSubject`.
     */
    protected setNewValue(value: T | null): void;
    /**
     * 	Method used for try to work out any method
     *  @protected
     *	@param {string} actionName - Action you try to fire. Used to show in Error text when something went wrong.
     *	@param {Function} actionFunc - Callback with logic. When something goes wrong - Error will be created.
     *	@return {Generic} result of the callback call.
     */
    protected tryDoAction<V>(actionName: string, actionFunc: () => any): V | undefined;
    /**
     *  Method that	processed error for user friendly error messages
     *  @protected
     *	@param {Error} error - Error.
     *	@param {string} actionName - Name of the action where error happened.
     */
    protected catchError(error: Error, actionName: string): void;
    private init;
    private _onActionLikeInvoked;
    private _onActionLikeInvokeEnd;
    private showConsoleWarningIfClassHaveNotDecorator;
    private initClassIdIfAbsent;
    /**
     *  Emits information about state changes into `ReplaySubject` at the `window`.
     *  Extension use this information to visually represent current state and history of states changes.
     *  @private
     */
    private emitMetadataOperation;
    static ɵfac: i0.ɵɵFactoryDeclaration<BaseState<any>, [{ optional: true; }, { optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<BaseState<any>>;
}
