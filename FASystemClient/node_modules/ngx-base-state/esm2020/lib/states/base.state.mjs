import { __decorate } from "tslib";
import { Inject, inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ɵNGX_STATE_DECORATOR_METADATA_FIELD } from '../constants';
import { ɵAction as Action } from '../decorators';
import { ɵMetadataKeyEnum, ɵMetadataOperationTypeEnum } from '../enums';
import { ɵMetadataStorage, ɵStackTrace } from '../helpers';
import { NGX_BASE_STATE_DEVTOOLS_CONFIG } from '../tokens';
import * as i0 from "@angular/core";
const INITIAL_DATA = new InjectionToken('__NGX_BASE_STATE_INITIAL_DATA');
const INITIAL_CONFIG = new InjectionToken('__NGX_BASE_STATE_INITIAL_CONFIG');
const CLASS_ID_FIELD = '_ɵID';
/**
 *	@class
 *	@classdes This is a base class that used for creating hight level state classes
 */
export class BaseState {
    constructor(
    /** Initial data should be passed via the `super` method call. */
    initialData = null, 
    /** Initial config should be passed via the `super` method call. */
    initialConfig = null) {
        this.initialData = initialData;
        this.initialConfig = initialConfig;
        this._devtoolsConfig = inject(NGX_BASE_STATE_DEVTOOLS_CONFIG);
        this._metadataStorage = inject(ɵMetadataStorage);
        this._currentlyInvokedAction = null;
        this._stackTraceOfCurrentlyInvokedAction = null;
        this._data$ = new BehaviorSubject(this.initialData);
        this.initClassIdIfAbsent();
        this.showConsoleWarningIfClassHaveNotDecorator();
        this.init();
    }
    /**
     * 	Get `Observable` with state data.
     *  @public
     *	@return {Generic} Observable with the state data.
     */
    get data$() {
        return this._data$.asObservable();
    }
    /**
     * 	Get state data.
     *  @public
     *	@return {Generic} State data.
     */
    get data() {
        return this._data$.value;
    }
    /**
     *  Base implementation of `ngOnDestroy`.
     *  Don't forget to call `super.ngOnDestroy` in case of override.
     *  @public
     */
    ngOnDestroy() {
        this.emitMetadataOperation(ɵMetadataOperationTypeEnum.Destroy);
    }
    /**
     *  Set new value to state
     *  @public
     *	@param {Generic} value - the value that should be set to update `BehaviorSubject`.
     */
    set(value) {
        this.setNewValue(value);
    }
    /**
     *  Clear state value. (Will be set `null`)
     *  @public
     */
    clear() {
        this.setNewValue(null);
    }
    /**
     *  Restore initial data from constructor.
     *  @public
     */
    restoreInitialData() {
        this.setNewValue(this.initialData);
    }
    /**
     *  Method for set data functionality. It may be expanded.
     *  The idea is to process the creation of new instances of complex structures.
     *  @protected
     *	@param {Generic | null} value - the value that should be set to update `BehaviorSubject`.
     */
    setNewValue(value) {
        this._data$.next(value);
        this.emitMetadataOperation(ɵMetadataOperationTypeEnum.Update);
    }
    /**
     * 	Method used for try to work out any method
     *  @protected
     *	@param {string} actionName - Action you try to fire. Used to show in Error text when something went wrong.
     *	@param {Function} actionFunc - Callback with logic. When something goes wrong - Error will be created.
     *	@return {Generic} result of the callback call.
     */
    tryDoAction(actionName, actionFunc) {
        try {
            return actionFunc();
        }
        catch (error) {
            this.catchError(error, actionName);
            return undefined;
        }
    }
    /**
     *  Method that	processed error for user friendly error messages
     *  @protected
     *	@param {Error} error - Error.
     *	@param {string} actionName - Name of the action where error happened.
     */
    catchError(error, actionName) {
        throw new Error(`\n${this.constructor.name} [${actionName}]: ${error.message}`);
    }
    init() {
        this.emitMetadataOperation(ɵMetadataOperationTypeEnum.Init);
    }
    // Using by decorators
    _onActionLikeInvoked(actionName) {
        if (this._devtoolsConfig.isEnabled && !this._currentlyInvokedAction) {
            this._currentlyInvokedAction = actionName;
            this._stackTraceOfCurrentlyInvokedAction = ɵStackTrace.capture();
        }
    }
    // Using by decorators
    _onActionLikeInvokeEnd() {
        if (this._devtoolsConfig.isEnabled) {
            this._currentlyInvokedAction = null;
            this._stackTraceOfCurrentlyInvokedAction = null;
        }
    }
    showConsoleWarningIfClassHaveNotDecorator() {
        if (this._devtoolsConfig.isEnabled && !this[ɵNGX_STATE_DECORATOR_METADATA_FIELD]) {
            console.warn(`${this.constructor.name} class is missed @NgxState() decorator. ` +
                `Some features of DevTools will work incorrectly!`);
        }
    }
    initClassIdIfAbsent() {
        if (!this.constructor[CLASS_ID_FIELD]) {
            this.constructor[CLASS_ID_FIELD] = Math.random();
        }
    }
    /**
     *  Emits information about state changes into `ReplaySubject` at the `window`.
     *  Extension use this information to visually represent current state and history of states changes.
     *  @private
     */
    emitMetadataOperation(type) {
        if (this._devtoolsConfig.isEnabled) {
            const operationEmitter$ = this._metadataStorage
                .get(ɵMetadataKeyEnum.MetadataOperation);
            operationEmitter$.next({
                type,
                classId: this.constructor[CLASS_ID_FIELD],
                className: this.constructor.name,
                classContext: this.initialConfig?.context,
                actionName: this._currentlyInvokedAction,
                date: new Date().toJSON(),
                data: this.data,
                stackTrace: this._stackTraceOfCurrentlyInvokedAction
            });
        }
    }
}
BaseState.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.4", ngImport: i0, type: BaseState, deps: [{ token: INITIAL_DATA, optional: true }, { token: INITIAL_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
BaseState.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.4", ngImport: i0, type: BaseState });
__decorate([
    Action
], BaseState.prototype, "set", null);
__decorate([
    Action
], BaseState.prototype, "clear", null);
__decorate([
    Action
], BaseState.prototype, "restoreInitialData", null);
__decorate([
    Action
], BaseState.prototype, "init", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.4", ngImport: i0, type: BaseState, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [INITIAL_DATA]
                }, {
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [INITIAL_CONFIG]
                }, {
                    type: Optional
                }] }]; }, propDecorators: { set: [], clear: [], restoreInitialData: [], init: [] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5zdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xpYnJhcnkvc3JjL2xpYi9zdGF0ZXMvYmFzZS5zdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBYSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEcsT0FBTyxFQUFFLGVBQWUsRUFBNkIsTUFBTSxNQUFNLENBQUM7QUFDbEUsT0FBTyxFQUFFLG1DQUFtQyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSwwQkFBMEIsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRTNELE9BQU8sRUFBRSw4QkFBOEIsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7QUFFM0QsTUFBTSxZQUFZLEdBQUcsSUFBSSxjQUFjLENBQUMsK0JBQStCLENBQUMsQ0FBQztBQUN6RSxNQUFNLGNBQWMsR0FBRyxJQUFJLGNBQWMsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQzdFLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQztBQUU5Qjs7O0dBR0c7QUFFSCxNQUFNLE9BQWdCLFNBQVM7SUErQjNCO0lBQ0ksaUVBQWlFO0lBRTlDLGNBQXdCLElBQUk7SUFDL0MsbUVBQW1FO0lBRWxELGdCQUF1QyxJQUFJO1FBSHpDLGdCQUFXLEdBQVgsV0FBVyxDQUFpQjtRQUc5QixrQkFBYSxHQUFiLGFBQWEsQ0FBOEI7UUFaL0Msb0JBQWUsR0FBRyxNQUFNLENBQUMsOEJBQThCLENBQUMsQ0FBQztRQUN6RCxxQkFBZ0IsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVyRCw0QkFBdUIsR0FBa0IsSUFBSSxDQUFDO1FBQzlDLHdDQUFtQyxHQUFvQixJQUFJLENBQUM7UUFVaEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFcEQsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLHlDQUF5QyxFQUFFLENBQUM7UUFDakQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUEzQ0Q7Ozs7T0FJRztJQUNILElBQVcsS0FBSztRQUNaLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsSUFBSTtRQUNYLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDN0IsQ0FBQztJQTZCRDs7OztPQUlHO0lBQ0ksV0FBVztRQUNkLElBQUksQ0FBQyxxQkFBcUIsQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUVJLEdBQUcsQ0FBQyxLQUFRO1FBQ2YsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7OztPQUdHO0lBRUksS0FBSztRQUNSLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUVJLGtCQUFrQjtRQUNyQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDTyxXQUFXLENBQUMsS0FBZTtRQUNqQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMscUJBQXFCLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLFdBQVcsQ0FBSSxVQUFrQixFQUFFLFVBQXFCO1FBQzlELElBQUk7WUFDQSxPQUFPLFVBQVUsRUFBRSxDQUFDO1NBQ3ZCO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDWixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQWMsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUU1QyxPQUFPLFNBQVMsQ0FBQztTQUNwQjtJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLFVBQVUsQ0FBQyxLQUFZLEVBQUUsVUFBa0I7UUFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFLLFVBQVUsTUFBTSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBR08sSUFBSTtRQUNSLElBQUksQ0FBQyxxQkFBcUIsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQsc0JBQXNCO0lBQ2Qsb0JBQW9CLENBQUMsVUFBa0I7UUFDM0MsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtZQUNqRSxJQUFJLENBQUMsdUJBQXVCLEdBQUcsVUFBVSxDQUFDO1lBQzFDLElBQUksQ0FBQyxtQ0FBbUMsR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDcEU7SUFDTCxDQUFDO0lBRUQsc0JBQXNCO0lBQ2Qsc0JBQXNCO1FBQzFCLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUU7WUFDaEMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksQ0FBQztZQUNwQyxJQUFJLENBQUMsbUNBQW1DLEdBQUcsSUFBSSxDQUFDO1NBQ25EO0lBQ0wsQ0FBQztJQUVPLHlDQUF5QztRQUM3QyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLEVBQUU7WUFDOUUsT0FBTyxDQUFDLElBQUksQ0FDUixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSwwQ0FBMEM7Z0JBQ2xFLGtEQUFrRCxDQUNyRCxDQUFDO1NBQ0w7SUFDTCxDQUFDO0lBRU8sbUJBQW1CO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ25DLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3BEO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxxQkFBcUIsQ0FBQyxJQUFnQztRQUMxRCxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFO1lBQ2hDLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQjtpQkFDMUMsR0FBRyxDQUFvQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBRWhGLGlCQUFpQixDQUFDLElBQUksQ0FBQztnQkFDbkIsSUFBSTtnQkFDSixPQUFPLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUM7Z0JBQ3pDLFNBQVMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUk7Z0JBQ2hDLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLE9BQU87Z0JBQ3pDLFVBQVUsRUFBRSxJQUFJLENBQUMsdUJBQXdCO2dCQUN6QyxJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUU7Z0JBQ3pCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZixVQUFVLEVBQUUsSUFBSSxDQUFDLG1DQUFvQzthQUN4RCxDQUFDLENBQUM7U0FDTjtJQUNMLENBQUM7O3NHQWxMaUIsU0FBUyxrQkFpQ2YsWUFBWSw2QkFHWixjQUFjOzBHQXBDUixTQUFTOztJQTREMUIsTUFBTTtvQ0FHTjs7SUFNQSxNQUFNO3NDQUdOOztJQU1BLE1BQU07bURBR047O0lBd0NBLE1BQU07cUNBR047MkZBNUhpQixTQUFTO2tCQUQ5QixVQUFVOzswQkFrQ0YsTUFBTTsyQkFBQyxZQUFZOzswQkFBRyxRQUFROzswQkFHOUIsTUFBTTsyQkFBQyxjQUFjOzswQkFBRyxRQUFROzRDQXlCOUIsR0FBRyxNQVNILEtBQUssTUFTTCxrQkFBa0IsTUEyQ2pCLElBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIGluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgybVOR1hfU1RBVEVfREVDT1JBVE9SX01FVEFEQVRBX0ZJRUxEIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IMm1QWN0aW9uIGFzIEFjdGlvbiB9IGZyb20gJy4uL2RlY29yYXRvcnMnO1xuaW1wb3J0IHsgybVNZXRhZGF0YUtleUVudW0sIMm1TWV0YWRhdGFPcGVyYXRpb25UeXBlRW51bSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IMm1TWV0YWRhdGFTdG9yYWdlLCDJtVN0YWNrVHJhY2UgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IMm1SW5pdGlhbENvbmZpZywgybVNZXRhZGF0YU9wZXJhdGlvbiB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTkdYX0JBU0VfU1RBVEVfREVWVE9PTFNfQ09ORklHIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuY29uc3QgSU5JVElBTF9EQVRBID0gbmV3IEluamVjdGlvblRva2VuKCdfX05HWF9CQVNFX1NUQVRFX0lOSVRJQUxfREFUQScpO1xuY29uc3QgSU5JVElBTF9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ19fTkdYX0JBU0VfU1RBVEVfSU5JVElBTF9DT05GSUcnKTtcbmNvbnN0IENMQVNTX0lEX0ZJRUxEID0gJ1/JtUlEJztcblxuLyoqXG4gKlx0QGNsYXNzXG4gKlx0QGNsYXNzZGVzIFRoaXMgaXMgYSBiYXNlIGNsYXNzIHRoYXQgdXNlZCBmb3IgY3JlYXRpbmcgaGlnaHQgbGV2ZWwgc3RhdGUgY2xhc3Nlc1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVN0YXRlPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBcdEdldCBgT2JzZXJ2YWJsZWAgd2l0aCBzdGF0ZSBkYXRhLlxuICAgICAqICBAcHVibGljXG4gICAgICpcdEByZXR1cm4ge0dlbmVyaWN9IE9ic2VydmFibGUgd2l0aCB0aGUgc3RhdGUgZGF0YS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGRhdGEkKCk6IE9ic2VydmFibGU8VCB8IG51bGw+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFx0R2V0IHN0YXRlIGRhdGEuXG4gICAgICogIEBwdWJsaWNcbiAgICAgKlx0QHJldHVybiB7R2VuZXJpY30gU3RhdGUgZGF0YS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGRhdGEoKTogVCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YSQudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXHRNYWluIGBCZWhhdmlvclN1YmplY3RgIHdpdGggc3RhdGUgZGF0YS5cbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9kYXRhJDogQmVoYXZpb3JTdWJqZWN0PFQgfCBudWxsPjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2RldnRvb2xzQ29uZmlnID0gaW5qZWN0KE5HWF9CQVNFX1NUQVRFX0RFVlRPT0xTX0NPTkZJRyk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbWV0YWRhdGFTdG9yYWdlID0gaW5qZWN0KMm1TWV0YWRhdGFTdG9yYWdlKTtcblxuICAgIHByaXZhdGUgX2N1cnJlbnRseUludm9rZWRBY3Rpb246IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgX3N0YWNrVHJhY2VPZkN1cnJlbnRseUludm9rZWRBY3Rpb246IHN0cmluZ1tdIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqIEluaXRpYWwgZGF0YSBzaG91bGQgYmUgcGFzc2VkIHZpYSB0aGUgYHN1cGVyYCBtZXRob2QgY2FsbC4gKi9cbiAgICAgICAgQEluamVjdChJTklUSUFMX0RBVEEpIEBPcHRpb25hbCgpXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBpbml0aWFsRGF0YTogVCB8IG51bGwgPSBudWxsLFxuICAgICAgICAvKiogSW5pdGlhbCBjb25maWcgc2hvdWxkIGJlIHBhc3NlZCB2aWEgdGhlIGBzdXBlcmAgbWV0aG9kIGNhbGwuICovXG4gICAgICAgIEBJbmplY3QoSU5JVElBTF9DT05GSUcpIEBPcHRpb25hbCgpXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbENvbmZpZzogybVJbml0aWFsQ29uZmlnIHwgbnVsbCA9IG51bGxcbiAgICApIHtcbiAgICAgICAgdGhpcy5fZGF0YSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuaW5pdGlhbERhdGEpO1xuXG4gICAgICAgIHRoaXMuaW5pdENsYXNzSWRJZkFic2VudCgpO1xuICAgICAgICB0aGlzLnNob3dDb25zb2xlV2FybmluZ0lmQ2xhc3NIYXZlTm90RGVjb3JhdG9yKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBCYXNlIGltcGxlbWVudGF0aW9uIG9mIGBuZ09uRGVzdHJveWAuXG4gICAgICogIERvbid0IGZvcmdldCB0byBjYWxsIGBzdXBlci5uZ09uRGVzdHJveWAgaW4gY2FzZSBvZiBvdmVycmlkZS5cbiAgICAgKiAgQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbWl0TWV0YWRhdGFPcGVyYXRpb24oybVNZXRhZGF0YU9wZXJhdGlvblR5cGVFbnVtLkRlc3Ryb3kpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXQgbmV3IHZhbHVlIHRvIHN0YXRlXG4gICAgICogIEBwdWJsaWNcbiAgICAgKlx0QHBhcmFtIHtHZW5lcmljfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSBzZXQgdG8gdXBkYXRlIGBCZWhhdmlvclN1YmplY3RgLlxuICAgICAqL1xuICAgIEBBY3Rpb25cbiAgICBwdWJsaWMgc2V0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0TmV3VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDbGVhciBzdGF0ZSB2YWx1ZS4gKFdpbGwgYmUgc2V0IGBudWxsYClcbiAgICAgKiAgQHB1YmxpY1xuICAgICAqL1xuICAgIEBBY3Rpb25cbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0TmV3VmFsdWUobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJlc3RvcmUgaW5pdGlhbCBkYXRhIGZyb20gY29uc3RydWN0b3IuXG4gICAgICogIEBwdWJsaWNcbiAgICAgKi9cbiAgICBAQWN0aW9uXG4gICAgcHVibGljIHJlc3RvcmVJbml0aWFsRGF0YSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXROZXdWYWx1ZSh0aGlzLmluaXRpYWxEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgTWV0aG9kIGZvciBzZXQgZGF0YSBmdW5jdGlvbmFsaXR5LiBJdCBtYXkgYmUgZXhwYW5kZWQuXG4gICAgICogIFRoZSBpZGVhIGlzIHRvIHByb2Nlc3MgdGhlIGNyZWF0aW9uIG9mIG5ldyBpbnN0YW5jZXMgb2YgY29tcGxleCBzdHJ1Y3R1cmVzLlxuICAgICAqICBAcHJvdGVjdGVkXG4gICAgICpcdEBwYXJhbSB7R2VuZXJpYyB8IG51bGx9IHZhbHVlIC0gdGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHNldCB0byB1cGRhdGUgYEJlaGF2aW9yU3ViamVjdGAuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNldE5ld1ZhbHVlKHZhbHVlOiBUIHwgbnVsbCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9kYXRhJC5uZXh0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5lbWl0TWV0YWRhdGFPcGVyYXRpb24oybVNZXRhZGF0YU9wZXJhdGlvblR5cGVFbnVtLlVwZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXHRNZXRob2QgdXNlZCBmb3IgdHJ5IHRvIHdvcmsgb3V0IGFueSBtZXRob2RcbiAgICAgKiAgQHByb3RlY3RlZFxuICAgICAqXHRAcGFyYW0ge3N0cmluZ30gYWN0aW9uTmFtZSAtIEFjdGlvbiB5b3UgdHJ5IHRvIGZpcmUuIFVzZWQgdG8gc2hvdyBpbiBFcnJvciB0ZXh0IHdoZW4gc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICpcdEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbkZ1bmMgLSBDYWxsYmFjayB3aXRoIGxvZ2ljLiBXaGVuIHNvbWV0aGluZyBnb2VzIHdyb25nIC0gRXJyb3Igd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqXHRAcmV0dXJuIHtHZW5lcmljfSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIGNhbGwuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHRyeURvQWN0aW9uPFY+KGFjdGlvbk5hbWU6IHN0cmluZywgYWN0aW9uRnVuYzogKCkgPT4gYW55KTogViB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uRnVuYygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jYXRjaEVycm9yKGVycm9yIGFzIEVycm9yLCBhY3Rpb25OYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBNZXRob2QgdGhhdFx0cHJvY2Vzc2VkIGVycm9yIGZvciB1c2VyIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2VzXG4gICAgICogIEBwcm90ZWN0ZWRcbiAgICAgKlx0QHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBFcnJvci5cbiAgICAgKlx0QHBhcmFtIHtzdHJpbmd9IGFjdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhY3Rpb24gd2hlcmUgZXJyb3IgaGFwcGVuZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhdGNoRXJyb3IoZXJyb3I6IEVycm9yLCBhY3Rpb25OYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXG4ke3RoaXMuY29uc3RydWN0b3IubmFtZX0gWyR7YWN0aW9uTmFtZX1dOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgQEFjdGlvblxuICAgIHByaXZhdGUgaW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbWl0TWV0YWRhdGFPcGVyYXRpb24oybVNZXRhZGF0YU9wZXJhdGlvblR5cGVFbnVtLkluaXQpO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIGJ5IGRlY29yYXRvcnNcbiAgICBwcml2YXRlIF9vbkFjdGlvbkxpa2VJbnZva2VkKGFjdGlvbk5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZGV2dG9vbHNDb25maWcuaXNFbmFibGVkICYmICF0aGlzLl9jdXJyZW50bHlJbnZva2VkQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50bHlJbnZva2VkQWN0aW9uID0gYWN0aW9uTmFtZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrVHJhY2VPZkN1cnJlbnRseUludm9rZWRBY3Rpb24gPSDJtVN0YWNrVHJhY2UuY2FwdHVyZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXNpbmcgYnkgZGVjb3JhdG9yc1xuICAgIHByaXZhdGUgX29uQWN0aW9uTGlrZUludm9rZUVuZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2RldnRvb2xzQ29uZmlnLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudGx5SW52b2tlZEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdGFja1RyYWNlT2ZDdXJyZW50bHlJbnZva2VkQWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd0NvbnNvbGVXYXJuaW5nSWZDbGFzc0hhdmVOb3REZWNvcmF0b3IoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9kZXZ0b29sc0NvbmZpZy5pc0VuYWJsZWQgJiYgIXRoaXNbybVOR1hfU1RBVEVfREVDT1JBVE9SX01FVEFEQVRBX0ZJRUxEXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgaXMgbWlzc2VkIEBOZ3hTdGF0ZSgpIGRlY29yYXRvci4gYCArXG4gICAgICAgICAgICAgICAgYFNvbWUgZmVhdHVyZXMgb2YgRGV2VG9vbHMgd2lsbCB3b3JrIGluY29ycmVjdGx5IWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRDbGFzc0lkSWZBYnNlbnQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3RvcltDTEFTU19JRF9GSUVMRF0pIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JbQ0xBU1NfSURfRklFTERdID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFbWl0cyBpbmZvcm1hdGlvbiBhYm91dCBzdGF0ZSBjaGFuZ2VzIGludG8gYFJlcGxheVN1YmplY3RgIGF0IHRoZSBgd2luZG93YC5cbiAgICAgKiAgRXh0ZW5zaW9uIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIHZpc3VhbGx5IHJlcHJlc2VudCBjdXJyZW50IHN0YXRlIGFuZCBoaXN0b3J5IG9mIHN0YXRlcyBjaGFuZ2VzLlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgZW1pdE1ldGFkYXRhT3BlcmF0aW9uKHR5cGU6IMm1TWV0YWRhdGFPcGVyYXRpb25UeXBlRW51bSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZGV2dG9vbHNDb25maWcuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25FbWl0dGVyJCA9IHRoaXMuX21ldGFkYXRhU3RvcmFnZVxuICAgICAgICAgICAgICAgIC5nZXQ8UmVwbGF5U3ViamVjdDzJtU1ldGFkYXRhT3BlcmF0aW9uPj4oybVNZXRhZGF0YUtleUVudW0uTWV0YWRhdGFPcGVyYXRpb24pO1xuXG4gICAgICAgICAgICBvcGVyYXRpb25FbWl0dGVyJC5uZXh0KHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGNsYXNzSWQ6IHRoaXMuY29uc3RydWN0b3JbQ0xBU1NfSURfRklFTERdLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGNsYXNzQ29udGV4dDogdGhpcy5pbml0aWFsQ29uZmlnPy5jb250ZXh0LFxuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWU6IHRoaXMuX2N1cnJlbnRseUludm9rZWRBY3Rpb24hLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9KU09OKCksXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgIHN0YWNrVHJhY2U6IHRoaXMuX3N0YWNrVHJhY2VPZkN1cnJlbnRseUludm9rZWRBY3Rpb24hXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==